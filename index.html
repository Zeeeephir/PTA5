<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Passpartout: Mon Salon Pixel Art</title>
    <!-- Tailwind CSS pour un style moderne et responsif -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Couleur de fond douce */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .pixel-font {
            font-family: 'Press Start 2P', cursive;
        }
        .game-container {
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 1400px; /* Plus large pour le canvas et les éléments */
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        /* Styles pour le wrapper du canvas pour maintenir le ratio d'aspect */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 1000px; /* Limite la largeur maximale du jeu */
            padding-bottom: 60%; /* 600 / 1000 = 0.6 = 60% pour maintenir le ratio 1000x600 */
            height: 0; /* Essentiel pour le padding-bottom hack */
            overflow: hidden; /* Cache tout ce qui dépasse du wrapper */
            border-radius: 10px; /* Bords arrondis pour correspondre au style */
            border: 2px solid #cbd5e1; /* Bordure subtile */
            background-color: #ffffff; /* Fond blanc */
        }
        .canvas-wrapper canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* Rendu pixelisé pour le canvas */
            cursor: crosshair;
        }
        .button-group button, .tool-button, .shop-item button, .char-option button {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-image: linear-gradient(to right, #6366f1, #8b5cf6); /* Dégradé de couleur */
        }
        .button-group button:hover, .tool-button:hover, .shop-item button:hover, .char-option button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
            background-image: linear-gradient(to right, #4f46e5, #7c3aed); /* Dégradé plus prononcé au survol */
        }
        .log-box {
            max-height: 150px;
            overflow-y: auto;
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            font-size: 0.9em;
            color: #475569;
        }
        .log-box p {
            margin-bottom: 5px;
        }
        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .stat-item span:first-child {
            font-weight: 600;
            color: #334155;
        }
        .stat-item span:last-child {
            color: #1e293b;
        }
        /* Style pour les messages d'erreur/information */
        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        .message-box.show {
            opacity: 1;
        }
        /* Style pour les cartes d'art dans la galerie */
        .art-card {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            background-color: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
        }
        .art-card img {
            width: 100%;
            height: 120px;
            object-fit: contain; /* Pour ne pas déformer l'image */
            background-color: #f8fafc;
            border-radius: 5px;
            margin-bottom: 10px;
            image-rendering: pixelated; /* Rendu pixelisé pour les images d'art */
        }
        .customer-dialog {
            background-color: #f0f9ff;
            border: 1px solid #bfdbfe;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            position: absolute; /* Positionné par rapport au conteneur du canvas */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10; /* Au-dessus du canvas */
            min-width: 300px;
        }
        .customer-dialog p {
            font-size: 1.1em;
            color: #1e40af;
            margin-bottom: 15px;
        }
        .customer-dialog button {
            background-color: #2563eb;
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .customer-dialog button:hover {
            background-color: #1d4ed8;
        }
        .shop-item {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .shop-item h3 {
            font-weight: bold;
            color: #334155;
            margin-bottom: 5px;
        }
        .shop-item p {
            font-size: 0.9em;
            color: #475569;
            margin-bottom: 10px;
        }
        .shop-item button {
            background-color: #10b981; /* Vert pour acheter */
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .shop-item button:hover {
            background-color: #059669;
        }

        /* Styles pour l'écran de démarrage */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #2d3748; /* Gris foncé */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
            text-align: center;
        }
        #startScreen h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #fcd34d; /* Jaune vif */
        }
        #characterCreation {
            background-color: #4a5568;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            max-width: 600px;
            width: 90%;
        }
        .char-option {
            background-color: #6366f1;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .char-option.selected {
            border-color: #fcd34d;
            box-shadow: 0 0 0 3px #fcd34d;
        }
        .char-preview-canvas {
            background-color: #333;
            border-radius: 5px;
            margin-bottom: 10px;
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
    <!-- Écran de Démarrage et Création de Personnage -->
    <div id="startScreen" class="pixel-font">
        <div id="characterCreation">
            <h1 class="text-4xl mb-6">Le Chemin de l'Artiste Pixel</h1>
            <p class="text-xl mb-4">Choisissez votre artiste et donnez-lui un nom !</p>
            <input type="text" id="artistNameInput" placeholder="Votre nom d'artiste" class="p-3 rounded-md text-gray-800 w-full mb-6 text-center" maxlength="15">

            <div class="grid grid-cols-2 gap-4 mb-6">
                <div class="char-option p-4 rounded-lg flex flex-col items-center" data-char="0">
                    <canvas class="char-preview-canvas" width="64" height="64"></canvas>
                    <span class="mt-2">Artiste Classique</span>
                </div>
                <div class="char-option p-4 rounded-lg flex flex-col items-center" data-char="1">
                    <canvas class="char-preview-canvas" width="64" height="64"></canvas>
                    <span class="mt-2">Artiste Moderne</span>
                </div>
            </div>
            <button id="startGameBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg text-xl">
                Commencer l'aventure !
            </button>
        </div>
    </div>

    <div class="game-container hidden">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6 pixel-font">Mon Salon Pixel Art</h1>

        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
            <div class="stat-item bg-blue-50 p-4 rounded-lg shadow-sm">
                <span class="text-blue-700">&#x1F4B0; Argent:</span>
                <span id="moneyDisplay" class="text-blue-900 font-semibold pixel-font">0</span>
            </div>
            <div class="stat-item bg-purple-50 p-4 rounded-lg shadow-sm">
                <span class="text-purple-700">&#x1F3C6; Réputation:</span>
                <span id="reputationDisplay" class="text-purple-900 font-semibold pixel-font">0</span>
            </div>
            <div class="stat-item bg-green-50 p-4 rounded-lg shadow-sm">
                <span class="text-green-700">&#x1F4BC; Renommée:</span>
                <span id="fameDisplay" class="text-green-900 font-semibold pixel-font">0</span>
            </div>
            <div class="stat-item bg-yellow-50 p-4 rounded-lg shadow-sm">
                <span class="text-yellow-700">&#x1F3A8; Statut:</span>
                <span id="statusDisplay" class="text-yellow-900 font-semibold pixel-font">Débutant</span>
            </div>
        </div>

        <!-- Zone principale du studio et de dessin -->
        <div class="relative drawing-area bg-gray-100 p-4 rounded-lg shadow-inner max-w-[1032px] mx-auto">
            <div class="flex flex-wrap gap-2 mb-4 items-center">
                <label for="brushSize" class="font-semibold text-gray-700 pixel-font">Taille:</label>
                <input type="range" id="brushSize" min="1" max="20" value="5" class="w-24">
                <label for="colorPicker" class="font-semibold text-gray-700 ml-4 pixel-font">Couleur:</label>
                <input type="color" id="colorPicker" value="#000000">
                <button id="clearCanvasBtn" class="tool-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg ml-auto pixel-font">
                    Effacer
                </button>
            </div>
            <div class="canvas-wrapper relative w-full max-w-[1000px] mx-auto" style="padding-bottom: 60%; height: 0; overflow: hidden;">
                <canvas id="studioCanvas" width="1000" height="600" class="absolute inset-0 w-full h-full"></canvas>
            </div>
            <div class="flex justify-center mt-4">
                <input type="text" id="artNameInput" placeholder="Nom de l'œuvre (optionnel)" class="p-2 border border-gray-300 rounded-md w-full max-w-sm mr-2 pixel-font">
                <button id="createArtBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg pixel-font">
                    Terminer l'œuvre
                </button>
            </div>

            <!-- Zone d'interaction client (positionnée absolument sur le canvas) -->
            <div id="customerInteraction" class="customer-dialog hidden pixel-font">
                <p id="customerMessage"></p>
                <div class="flex justify-center gap-4 mt-4">
                    <button id="acceptOfferBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">
                        Accepter
                    </button>
                    <button id="rejectOfferBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">
                        Refuser
                    </button>
                </div>
            </div>

            <!-- Boîte de dialogue du Tuto -->
            <div id="tutorialDialog" class="customer-dialog hidden pixel-font">
                <p id="tutorialMessage"></p>
                <button id="nextTutorialBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg mt-4">
                    Suivant
                </button>
            </div>
        </div>

        <!-- Boutique d'améliorations -->
        <h2 class="text-xl font-semibold text-gray-700 mt-6 mb-3 pixel-font">Boutique d'Améliorations:</h2>
        <div id="shopDisplay" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4 mb-6">
            <!-- Les articles de la boutique seront affichés ici -->
        </div>

        <h2 class="text-xl font-semibold text-gray-700 mt-6 mb-3 pixel-font">Votre Galerie:</h2>
        <div id="galleryDisplay" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4 mb-6">
            <!-- Les œuvres d'art seront affichées ici -->
            <p class="text-gray-500 col-span-full text-center pixel-font" id="noArtMessage">Votre galerie est vide. Créez une œuvre !</p>
        </div>

        <h2 class="text-xl font-semibold text-gray-700 mt-6 mb-3 pixel-font">Journal de Bord:</h2>
        <div id="logBox" class="log-box pixel-font">
            <!-- Les messages du jeu apparaîtront ici -->
        </div>
    </div>

    <!-- Message Box pour les notifications -->
    <div id="messageBox" class="message-box pixel-font"></div>

    <script>
        // Initialisation du jeu après le chargement complet de la fenêtre
        window.onload = function() {
            setupStartScreen();
        };

        // --- Variables Globales du Jeu ---
        const startScreen = document.getElementById('startScreen');
        const gameContainer = document.querySelector('.game-container');
        const studioCanvas = document.getElementById('studioCanvas');
        const ctx = studioCanvas.getContext('2d');

        const moneyDisplay = document.getElementById('moneyDisplay');
        const reputationDisplay = document.getElementById('reputationDisplay');
        const fameDisplay = document.getElementById('fameDisplay');
        const statusDisplay = document.getElementById('statusDisplay');
        const galleryDisplay = document.getElementById('galleryDisplay');
        const noArtMessage = document.getElementById('noArtMessage');
        const logBox = document.getElementById('logBox');
        const messageBox = document.getElementById('messageBox');

        const brushSizeInput = document.getElementById('brushSize');
        const colorPicker = document.getElementById('colorPicker');
        const clearCanvasBtn = document.getElementById('clearCanvasBtn');
        const artNameInput = document.getElementById('artNameInput');
        const createArtBtn = document.getElementById('createArtBtn');

        const customerInteraction = document.getElementById('customerInteraction');
        const customerMessage = document.getElementById('customerMessage');
        const acceptOfferBtn = document.getElementById('acceptOfferBtn');
        const rejectOfferBtn = document.getElementById('rejectOfferBtn');
        const shopDisplay = document.getElementById('shopDisplay');

        const tutorialDialog = document.getElementById('tutorialDialog');
        const tutorialMessage = document.getElementById('tutorialMessage');
        const nextTutorialBtn = document.getElementById('nextTutorialBtn');

        // État du joueur
        let player = {
            name: "Artiste",
            character: null, // L'objet du personnage pixelisé choisi
            money: 100, // Argent de départ
            reputation: 0,
            fame: 1, // Renommée, influence la qualité de base et les clients
            status: "Débutant", // Statut de l'artiste
            inventory: [], // Œuvres d'art créées
            artIdCounter: 0, // Compteur pour les IDs uniques des œuvres
            rentDueIn: 30, // Jours avant le paiement du loyer
            rentAmount: 20, // Montant du loyer
            upgrades: [] // Améliorations achetées
        };

        // État du dessin
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let brushSize = parseInt(brushSizeInput.value);
        let currentColor = colorPicker.value;
        let drawnPixels = new Set(); // Pour estimer la "complexité" de l'œuvre
        let currentDrawingData = null; // Pour stocker l'image du dessin en cours

        // Zone de dessin sur le canvas principal (simule l'emplacement de l'easel)
        const artDrawingArea = {
            x: 650, // Position X sur le canvas (ajusté pour 1000x600)
            y: 150, // Position Y sur le canvas (ajusté pour 1000x600)
            width: 250, // Largeur de la zone de dessin (ajusté)
            height: 250 // Hauteur de la zone de dessin (ajusté)
        };

        // État du client
        let customers = []; // Liste des clients dans le studio
        let currentCustomerInteraction = null; // Le client actuellement en interaction
        let currentArtForSale = null; // L'œuvre proposée au client actuel
        let currentOffer = 0;

        // État du tutoriel
        let tutorialActive = false;
        let tutorialStep = 0;
        let tutorialNPC = null; // Le PNJ du tutoriel

        // Définitions des personnages pixel art
        const pixelCharacters = [
            {
                name: "Artiste Classique",
                colors: { body: '#e53e3e', head: '#f6e0b5', hair: '#8B4513' },
                draw: function(ctx, x, y, size) {
                    const s = size / 8; // Taille d'un pixel pour le personnage
                    // Corps
                    ctx.fillStyle = this.colors.body;
                    ctx.fillRect(x + s*2, y + s*4, s*4, s*4);
                    // Tête
                    ctx.fillStyle = this.colors.head;
                    ctx.fillRect(x + s*3, y + s*1, s*2, s*3);
                    // Cheveux
                    ctx.fillStyle = this.colors.hair;
                    ctx.fillRect(x + s*2, y + s*0, s*4, s*2);
                    // Bras
                    ctx.fillStyle = this.colors.body;
                    ctx.fillRect(x + s*1, y + s*5, s, s*2);
                    ctx.fillRect(x + s*6, y + s*5, s, s*2);
                }
            },
            {
                name: "Artiste Moderne",
                colors: { body: '#4299e1', head: '#f6e0b5', hair: '#000000' },
                draw: function(ctx, x, y, size) {
                    const s = size / 8; // Taille d'un pixel pour le personnage
                    // Corps
                    ctx.fillStyle = this.colors.body;
                    ctx.fillRect(x + s*2, y + s*4, s*4, s*4);
                    // Tête
                    ctx.fillStyle = this.colors.head;
                    ctx.fillRect(x + s*2, y + s*1, s*4, s*3);
                    // Cheveux (carrés)
                    ctx.fillStyle = this.colors.hair;
                    ctx.fillRect(x + s*2, y + s*0, s*4, s*2);
                    // Lunettes
                    ctx.fillStyle = '#333';
                    ctx.fillRect(x + s*2, y + s*2, s, s);
                    ctx.fillRect(x + s*5, y + s*2, s, s);
                }
            }
        ];

        // Types de clients avec leurs préférences et tolérances
        const customerTypes = [
            { name: "Sceptique", minFame: 0, qualityPref: { min: 0, max: 40 }, priceTolerance: { min: 0.5, max: 0.8 }, messages: ["C'est... intéressant.", "Je ne suis pas sûr de comprendre.", "Combien pour ça ?"], colors: { body: '#a0aec0', head: '#f6e0b5' } },
            { name: "Amateur d'art", minFame: 10, qualityPref: { min: 30, max: 70 }, priceTolerance: { min: 0.8, max: 1.2 }, messages: ["J'aime la couleur !", "C'est très expressif.", "Un prix juste, s'il vous plaît."], colors: { body: '#f6ad55', head: '#f6e0b5' } },
            { name: "Collectionneur", minFame: 50, qualityPref: { min: 60, max: 100 }, priceTolerance: { min: 1.0, max: 1.5 }, messages: ["Magnifique ! Une pièce de collection.", "Je dois avoir ça dans ma galerie.", "Quel est votre meilleur prix ?"], colors: { body: '#667eea', head: '#f6e0b5' } }
        ];

        // Articles de la boutique (avec leurs positions dans le studio)
        const shopItems = [
            // Note: 'easel' est maintenant la zone de dessin, pas un objet achetable distinct
            { id: 'decor', name: 'Décoration Murale', cost: 30, description: 'Améliore l\'ambiance du studio, attire plus de clients.', effect: { reputation: 5 }, bought: false, studioX: 100, studioY: 50, width: 80, height: 60, type: 'decor'},
            { id: 'lights', name: 'Éclairage d\'Atelier', cost: 75, description: 'Rend vos couleurs plus éclatantes, améliore la qualité.', effect: { fame: 0.2 }, bought: false, studioX: studioCanvas.width / 2, studioY: 30, width: 40, height: 40, type: 'light'},
            { id: 'sofa', name: 'Canapé Confortable', cost: 60, description: 'Les clients attendent plus longtemps, plus de chances de vente.', effect: { customerWaitTime: 10 }, bought: false, studioX: 100, studioY: studioCanvas.height - 120, width: 150, height: 80, type: 'sofa'}
        ];

        // --- Fonctions Utilitaires ---

        /**
         * Affiche un message temporaire à l'écran.
         * @param {string} message - Le message à afficher.
         * @param {string} type - Le type de message (ex: 'info', 'error', 'success').
         */
        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.className = 'message-box show pixel-font'; // Réinitialise et ajoute la classe show
            if (type === 'error') {
                messageBox.style.backgroundColor = '#dc2626'; // Rouge pour les erreurs
            } else if (type === 'success') {
                messageBox.style.backgroundColor = '#16a34a'; // Vert pour le succès
            } else {
                messageBox.style.backgroundColor = '#333'; // Gris par défaut
            }
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3000); // Le message disparaît après 3 secondes
        }

        /**
         * Ajoute un message au journal de bord du jeu.
         * @param {string} message - Le message à ajouter.
         */
        function addLogMessage(message) {
            const p = document.createElement('p');
            p.textContent = message;
            logBox.prepend(p); // Ajoute le message en haut
            // Limite le nombre de messages pour éviter l'encombrement
            if (logBox.children.length > 30) {
                logBox.removeChild(logBox.lastChild);
            }
        }

        /**
         * Met à jour l'affichage des statistiques du joueur.
         */
        function updateStatsDisplay() {
            moneyDisplay.textContent = player.money.toFixed(0) + ' €'; // Arrondi pour le pixel art
            reputationDisplay.textContent = player.reputation;
            fameDisplay.textContent = player.fame.toFixed(1);
            statusDisplay.textContent = player.status;
        }

        /**
         * Met à jour l'affichage de la galerie d'œuvres d'art.
         */
        function updateGalleryDisplay() {
            galleryDisplay.innerHTML = ''; // Vide la galerie actuelle
            if (player.inventory.length === 0) {
                noArtMessage.style.display = 'block';
                galleryDisplay.appendChild(noArtMessage);
            } else {
                noArtMessage.style.display = 'none';
                player.inventory.forEach(art => {
                    const artCard = document.createElement('div');
                    artCard.className = 'art-card';
                    artCard.innerHTML = `
                        <img src="${art.dataURL}" alt="${art.name || 'Œuvre sans titre'}">
                        <h3 class="font-bold text-md text-gray-800 mb-1 pixel-font">${art.name || 'Œuvre sans titre'}</h3>
                        <p class="text-xs text-gray-600 pixel-font">Qualité: ${art.quality.toFixed(1)}</p>
                        <p class="text-xs text-gray-600 pixel-font">Valeur: ${art.baseValue.toFixed(0)} €</p>
                        <button data-id="${art.id}" class="sell-item-btn mt-3 bg-purple-500 hover:bg-purple-600 text-white text-sm font-semibold py-2 px-4 rounded-md pixel-font">
                            Mettre en vente
                        </button>
                    `;
                    galleryDisplay.appendChild(artCard);
                });

                // Attache les écouteurs d'événements aux nouveaux boutons "Mettre en vente"
                document.querySelectorAll('.sell-item-btn').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const artId = parseInt(event.target.dataset.id);
                        offerArtToCustomer(artId);
                    });
                });
            }
        }

        /**
         * Met à jour le statut de l'artiste en fonction de sa renommée.
         */
        function updateArtistStatus() {
            if (player.fame >= 100) {
                player.status = "Maître Artiste";
            } else if (player.fame >= 50) {
                player.status = "Artiste Reconnu";
            } else if (player.fame >= 20) {
                player.status = "Artiste Émergent";
            } else {
                player.status = "Débutant";
            }
        }

        /**
         * Met à jour l'affichage de la boutique.
         */
        function updateShopDisplay() {
            shopDisplay.innerHTML = '';
            shopItems.forEach(item => {
                const itemCard = document.createElement('div');
                itemCard.className = 'shop-item';
                itemCard.innerHTML = `
                    <h3 class="pixel-font">${item.name}</h3>
                    <p class="pixel-font">${item.description}</p>
                    <p class="font-semibold pixel-font">${item.cost} €</p>
                    <button data-id="${item.id}" ${item.bought ? 'disabled' : ''} class="buy-item-btn mt-2 bg-green-500 hover:bg-green-600 text-white text-sm font-semibold py-2 px-4 rounded-md pixel-font ${item.bought ? 'opacity-50 cursor-not-allowed' : ''}">
                        ${item.bought ? 'Acheté' : 'Acheter'}
                    </button>
                `;
                shopDisplay.appendChild(itemCard);
            });

            document.querySelectorAll('.buy-item-btn').forEach(button => {
                if (!button.disabled) {
                    button.addEventListener('click', (event) => {
                        const itemId = event.target.dataset.id;
                        buyShopItem(itemId);
                    });
                }
            });
        }

        // --- Logique de Dessin sur Canvas ---

        /**
         * Commence le dessin lorsque la souris est pressée.
         * @param {MouseEvent} e - L'événement de la souris.
         */
        function startDrawing(e) {
            // Vérifie si le clic est dans la zone de dessin de l'œuvre
            const rect = studioCanvas.getBoundingClientRect();
            const scaleX = studioCanvas.width / rect.width;
            const scaleY = studioCanvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;

            if (mouseX >= artDrawingArea.x && mouseX <= artDrawingArea.x + artDrawingArea.width &&
                mouseY >= artDrawingArea.y && mouseY <= artDrawingArea.y + artDrawingArea.height) {
                isDrawing = true;
                [lastX, lastY] = [mouseX, mouseY];
                // Enregistre les pixels dessinés pour l'estimation de la complexité
                drawnPixels.add(`${Math.floor((mouseX - artDrawingArea.x) / 5)},${Math.floor((mouseY - artDrawingArea.y) / 5)}`);
            }
        }

        /**
         * Dessine une ligne lorsque la souris est déplacée et pressée.
         * @param {MouseEvent} e - L'événement de la souris.
         */
        function draw(e) {
            if (!isDrawing) return;

            const rect = studioCanvas.getBoundingClientRect();
            const scaleX = studioCanvas.width / rect.width;
            const scaleY = studioCanvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;

            // S'assure de ne dessiner que dans la zone de l'œuvre
            if (mouseX >= artDrawingArea.x && mouseX <= artDrawingArea.x + artDrawingArea.width &&
                mouseY >= artDrawingArea.y && mouseY <= artDrawingArea.y + artDrawingArea.height) {

                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(mouseX, mouseY);
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();

                // Enregistre les pixels traversés pour l'estimation de la complexité
                const dx = mouseX - lastX;
                const dy = mouseY - lastY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                for (let i = 0; i < distance; i += 5) { // Échantillonne tous les 5 pixels
                    const x = lastX + (dx / distance) * i;
                    const y = lastY + (dy / distance) * i;
                    drawnPixels.add(`${Math.floor((x - artDrawingArea.x) / 5)},${Math.floor((y - artDrawingArea.y) / 5)}`);
                }

                [lastX, lastY] = [mouseX, mouseY];
            } else {
                // Si la souris sort de la zone de dessin pendant le dessin, arrête le dessin
                isDrawing = false;
            }
        }

        /**
         * Arrête le dessin lorsque la souris est relâchée ou quitte le canvas.
         */
        function stopDrawing() {
            isDrawing = false;
        }

        /**
         * Efface le contenu du canvas dans la zone de dessin de l'œuvre.
         */
        function clearCanvas() {
            ctx.clearRect(artDrawingArea.x, artDrawingArea.y, artDrawingArea.width, artDrawingArea.height);
            ctx.fillStyle = '#ffffff'; // Réinitialise le fond en blanc
            ctx.fillRect(artDrawingArea.x, artDrawingArea.y, artDrawingArea.width, artDrawingArea.height);
            drawnPixels.clear(); // Réinitialise les pixels dessinés
            currentDrawingData = null; // Efface l'image du dessin en cours
            addLogMessage("Le canvas a été effacé. Prêt pour une nouvelle œuvre !");
        }

        // --- Logique du Jeu ---

        /**
         * Configure l'écran de démarrage et la création de personnage.
         */
        function setupStartScreen() {
            const charOptions = document.querySelectorAll('.char-option');
            let selectedCharIndex = 0; // Par défaut, le premier personnage est sélectionné

            // Dessine les aperçus des personnages
            charOptions.forEach((option, index) => {
                const previewCanvas = option.querySelector('.char-preview-canvas');
                const previewCtx = previewCanvas.getContext('2d');
                pixelCharacters[index].draw(previewCtx, 0, 0, previewCanvas.width); // Dessine le personnage
                option.dataset.charIndex = index; // Stocke l'index du personnage
            });

            // Sélectionne le premier personnage par défaut
            charOptions[selectedCharIndex].classList.add('selected');
            player.character = pixelCharacters[selectedCharIndex];

            charOptions.forEach(option => {
                option.addEventListener('click', () => {
                    charOptions.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    selectedCharIndex = parseInt(option.dataset.charIndex);
                    player.character = pixelCharacters[selectedCharIndex];
                });
            });

            document.getElementById('startGameBtn').addEventListener('click', () => {
                console.log("Start Game button clicked!"); // Debugging line
                try {
                    const artistName = document.getElementById('artistNameInput').value.trim();
                    if (artistName) {
                        player.name = artistName;
                    } else {
                        player.name = "Artiste Inconnu";
                    }
                    startScreen.classList.add('hidden');
                    gameContainer.classList.remove('hidden');
                    initGame();
                    startTutorial(); // Lance le tutoriel après le démarrage du jeu
                    console.log("Game started successfully."); // Debugging line
                } catch (error) {
                    console.error("Error starting game:", error); // Debugging error
                    showMessage("Une erreur est survenue au démarrage du jeu.", 'error');
                }
            });
        }

        /**
         * Initialise l'état du jeu et les écouteurs d'événements.
         */
        function initGame() {
            // Configure le canvas pour le dessin
            // Les dimensions du canvas sont maintenant définies dans le HTML
            clearCanvas(); // Efface la zone de dessin initiale

            // Écouteurs d'événements pour le dessin
            studioCanvas.addEventListener('mousedown', startDrawing);
            studioCanvas.addEventListener('mousemove', draw);
            studioCanvas.addEventListener('mouseup', stopDrawing);
            studioCanvas.addEventListener('mouseout', stopDrawing); // Arrête le dessin si la souris quitte le canvas

            // Écouteurs pour les outils de dessin
            brushSizeInput.addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
            });
            colorPicker.addEventListener('input', (e) => {
                currentColor = e.target.value;
            });
            clearCanvasBtn.addEventListener('click', clearCanvas);

            // Écouteur pour le bouton "Terminer l'œuvre"
            createArtBtn.addEventListener('click', createArt);

            // Écouteurs pour les boutons d'offre client
            acceptOfferBtn.addEventListener('click', acceptOffer);
            rejectOfferBtn.addEventListener('click', rejectOffer);

            nextTutorialBtn.addEventListener('click', advanceTutorial);

            updateStatsDisplay();
            updateGalleryDisplay();
            updateShopDisplay();
            addLogMessage(`Bienvenue, ${player.name} ! Préparez-vous à devenir un artiste de renommée mondiale.`);

            // Démarrer la boucle de jeu principale (gestion du temps, clients, loyer)
            setInterval(gameTick, 1000); // Chaque seconde
            // Les clients n'apparaissent qu'après le tutoriel
        }

        /**
         * Fonction de "tick" du jeu, appelée périodiquement.
         */
        function gameTick() {
            if (!tutorialActive) { // Le loyer et les clients ne sont actifs qu'après le tutoriel
                player.rentDueIn--;
                if (player.rentDueIn <= 0) {
                    payRent();
                    player.rentDueIn = 30; // Réinitialise le compteur de loyer
                }
            }

            // Mettre à jour la position des clients et du PNJ du tutoriel
            [...customers, tutorialNPC].filter(Boolean).forEach(entity => {
                if (entity.state === 'entering') {
                    entity.x += entity.speed;
                    if (entity.x >= entity.targetX) {
                        entity.x = entity.targetX;
                        entity.state = 'viewing';
                        entity.viewingTime = 0;
                    }
                } else if (entity.state === 'viewing') {
                    entity.viewingTime++;
                    if (entity === tutorialNPC) return; // Le PNJ du tuto ne part pas seul

                    // Le client part après un certain temps, ou s'il n'y a pas d'œuvres à vendre
                    let maxViewTime = 10 + (player.upgrades.find(u => u.id === 'sofa') ? 10 : 0); // Canapé augmente le temps d'attente
                    if (entity.viewingTime > maxViewTime && !currentCustomerInteraction) { // S'il n'est pas en interaction
                        if (player.inventory.length === 0) {
                            entity.state = 'leaving';
                            addLogMessage(`${entity.name} est parti car il n'y avait rien à voir.`);
                        } else if (Math.random() < 0.3) { // 30% de chance qu'il parte s'il n'y a pas d'interaction
                            entity.state = 'leaving';
                            addLogMessage(`${entity.name} est parti sans acheter.`);
                        }
                    }
                } else if (entity.state === 'leaving') {
                    entity.x += entity.speed; // Il continue de se déplacer vers la droite
                    if (entity.x > studioCanvas.width + 50) { // Hors de l'écran
                        customers = customers.filter(c => c !== entity); // Retire le client
                    }
                }
            });
        }

        /**
         * Gère le paiement du loyer.
         */
        function payRent() {
            if (player.money >= player.rentAmount) {
                player.money -= player.rentAmount;
                addLogMessage(`Vous avez payé le loyer de ${player.rentAmount} €. Il vous reste ${player.money.toFixed(0)} €.`);
                showMessage(`Loyer de ${player.rentAmount} € payé.`, 'info');
            } else {
                player.money -= player.rentAmount; // Le loyer est dû même si pas assez d'argent
                addLogMessage(`Vous n'avez pas assez d'argent pour le loyer ! Vous êtes endetté de ${player.money < 0 ? Math.abs(player.money).toFixed(0) : 0} €. Votre réputation en prend un coup.`);
                showMessage("Pas assez d'argent pour le loyer !", 'error');
                player.reputation = Math.max(0, player.reputation - 10); // Pénalité de réputation
            }
            updateStatsDisplay();
        }

        /**
         * Calcule la qualité d'une œuvre en fonction du dessin et de la renommée du joueur.
         * @returns {number} La qualité de l'œuvre (entre 1 et 100).
         */
        function calculateArtQuality() {
            // La qualité est influencée par:
            // 1. La "complexité" du dessin (nombre de pixels dessinés)
            // 2. La renommée du joueur
            // 3. Les améliorations du studio (ex: easel)
            const artAreaPixels = (artDrawingArea.width / 5) * (artDrawingArea.height / 5);
            const pixelDensity = drawnPixels.size / artAreaPixels;
            let baseQuality = (pixelDensity * 70) + (player.fame * 0.5); // Max 70 pour densité, plus renommée

            // Bonus des améliorations
            if (player.upgrades.find(u => u.id === 'lights')) {
                baseQuality += 5; // Bonus de qualité pour l'éclairage
            }

            baseQuality = Math.min(100, Math.max(1, baseQuality)); // S'assure que c'est entre 1 et 100

            // Ajoute une petite variation aléatoire
            const finalQuality = baseQuality + (Math.random() * 20 - 10); // +/- 10
            return Math.max(1, Math.min(100, finalQuality));
        }

        /**
         * Crée une nouvelle œuvre d'art à partir du contenu du canvas.
         */
        function createArt() {
            if (drawnPixels.size < 50) { // Exige un minimum de dessin pour considérer l'œuvre "terminée"
                showMessage("Dessinez quelque chose avant de terminer l'œuvre !", 'error');
                return;
            }

            const artName = artNameInput.value.trim() || `Œuvre #${player.artIdCounter + 1}`;
            const quality = calculateArtQuality();
            const baseValue = (quality * 5) + (player.fame * 2) + (Math.random() * 50); // Valeur de base influencée par qualité et renommée
            const value = Math.round(baseValue);

            // Capture uniquement la zone de dessin de l'œuvre
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = artDrawingArea.width;
            tempCanvas.height = artDrawingArea.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(studioCanvas, artDrawingArea.x, artDrawingArea.y, artDrawingArea.width, artDrawingArea.height, 0, 0, artDrawingArea.width, artDrawingArea.height);

            const newArt = {
                id: player.artIdCounter++,
                name: artName,
                dataURL: tempCanvas.toDataURL(), // Sauvegarde l'image de la zone de dessin
                quality: quality,
                baseValue: value // Valeur de base avant négociation
            };

            player.inventory.push(newArt);
            addLogMessage(`Vous avez terminé l'œuvre "${newArt.name}" (Qualité: ${newArt.quality.toFixed(1)}, Valeur estimée: ${newArt.baseValue.toFixed(0)} €).`);
            showMessage(`Œuvre "${newArt.name}" créée !`, 'success');

            // Efface le canvas et réinitialise pour la prochaine œuvre
            clearCanvas();
            artNameInput.value = '';
            updateGalleryDisplay();
            updateStatsDisplay(); // Pour voir la renommée potentiellement augmenter plus tard
        }

        /**
         * Fait apparaître un nouveau client.
         */
        function spawnCustomer() {
            // Limite le nombre de clients présents en même temps
            if (customers.length >= 3 || tutorialActive) return; // Pas de clients pendant le tuto

            // Sélectionne un client en fonction de la renommée du joueur
            const availableCustomers = customerTypes.filter(c => player.fame >= c.minFame);
            if (availableCustomers.length === 0) {
                addLogMessage("Aucun client disponible pour votre niveau de renommée actuel. Continuez à améliorer votre renommée !");
                return;
            }
            const customerType = availableCustomers[Math.floor(Math.random() * availableCustomers.length)];

            const newCustomer = {
                ...customerType,
                x: -50, // Commence hors de l'écran à gauche
                y: studioCanvas.height / 2 + (Math.random() * 100 - 50), // Position Y aléatoire dans le studio
                speed: 1 + Math.random() * 0.5, // Vitesse de déplacement
                targetX: Math.random() * (studioCanvas.width - 200) + 50, // Position aléatoire où il s'arrête
                state: 'entering', // 'entering', 'viewing', 'leaving'
                viewingTime: 0 // Temps passé à regarder
            };
            customers.push(newCustomer);
            addLogMessage(`${newCustomer.name} est entré dans votre studio.`);
            showMessage(`${newCustomer.name} est arrivé !`, 'info');
        }

        /**
         * Propose une œuvre d'art spécifique au client actuel.
         * @param {number} artId - L'ID de l'œuvre à proposer.
         */
        function offerArtToCustomer(artId) {
            if (customers.length === 0) {
                showMessage("Il n'y a pas de client dans le studio pour le moment.", 'error');
                return;
            }
            if (currentCustomerInteraction) {
                showMessage("Un client examine déjà une œuvre. Attendez sa décision.", 'error');
                return;
            }

            const artIndex = player.inventory.findIndex(art => art.id === artId);
            if (artIndex === -1) {
                showMessage("Erreur: Cette œuvre n'existe pas dans votre inventaire.", 'error');
                return;
            }

            currentArtForSale = player.inventory[artIndex];
            // Sélectionne un client aléatoire parmi ceux qui sont en mode 'viewing'
            const potentialCustomers = customers.filter(c => c.state === 'viewing');
            if (potentialCustomers.length === 0) {
                showMessage("Aucun client n'est disponible pour interagir en ce moment.", 'error');
                return;
            }
            currentCustomerInteraction = potentialCustomers[Math.floor(Math.random() * potentialCustomers.length)];


            // Calcule l'offre du client
            let customerInterest = 1;
            // Plus la qualité correspond aux préférences du client, plus l'intérêt est élevé
            if (currentArtForSale.quality >= currentCustomerInteraction.qualityPref.min && currentArtForSale.quality <= currentCustomerInteraction.qualityPref.max) {
                customerInterest = 1.2; // Bonne correspondance
            } else if (currentArtForSale.quality < currentCustomerInteraction.qualityPref.min) {
                customerInterest = 0.7; // Trop faible qualité
            } else {
                customerInterest = 0.9; // Trop haute qualité ou hors de leur zone de confort
            }

            // L'offre est basée sur la valeur de base de l'œuvre, l'intérêt du client et sa tolérance au prix
            currentOffer = currentArtForSale.baseValue * customerInterest *
                            (currentCustomerInteraction.priceTolerance.min + Math.random() * (currentCustomerInteraction.priceTolerance.max - currentCustomerInteraction.priceTolerance.min));
            currentOffer = Math.round(currentOffer);

            customerMessage.textContent = `${currentCustomerInteraction.name} dit: "${currentCustomerInteraction.messages[Math.floor(Math.random() * currentCustomerInteraction.messages.length)]}" Je vous offre ${currentOffer.toFixed(0)} € pour "${currentArtForSale.name}".`;
            customerInteraction.classList.remove('hidden');
            addLogMessage(`${currentCustomerInteraction.name} offre ${currentOffer.toFixed(0)} € pour "${currentArtForSale.name}".`);
        }

        /**
         * Accepte l'offre du client.
         */
        function acceptOffer() {
            if (!currentArtForSale || !currentCustomerInteraction) return;

            player.money += currentOffer;
            player.inventory = player.inventory.filter(art => art.id !== currentArtForSale.id); // Retire l'œuvre

            // Ajuste la réputation et la renommée
            const qualityDifference = currentArtForSale.quality - ((currentCustomerInteraction.qualityPref.min + currentCustomerInteraction.qualityPref.max) / 2);
            if (qualityDifference > 10) { // Bonne vente, bonne qualité
                player.reputation += 5;
                player.fame += 0.5;
                addLogMessage(`Vente réussie ! "${currentArtForSale.name}" vendu pour ${currentOffer.toFixed(0)} €. Votre réputation et renommée augmentent !`);
                showMessage(`Vendu ! +${currentOffer.toFixed(0)} €`, 'success');
            } else if (qualityDifference < -10) { // Mauvaise vente, faible qualité
                player.reputation = Math.max(0, player.reputation - 5);
                player.fame = Math.max(1, player.fame - 0.2);
                addLogMessage(`Vente de "${currentArtForSale.name}" pour ${currentOffer.toFixed(0)} €. La faible qualité a légèrement affecté votre réputation.`);
                showMessage(`Vendu. Réputation affectée.`, 'info');
            } else { // Vente neutre
                addLogMessage(`Vente de "${currentArtForSale.name}" pour ${currentOffer.toFixed(0)} €.`);
                showMessage(`Vendu pour ${currentOffer.toFixed(0)} €`, 'success');
            }

            // Le client qui a acheté l'œuvre quitte le studio
            currentCustomerInteraction.state = 'leaving';

            resetCustomerInteraction();
            updateStatsDisplay();
            updateGalleryDisplay();
            updateArtistStatus();
        }

        /**
         * Refuse l'offre du client.
         */
        function rejectOffer() {
            if (!currentArtForSale || !currentCustomerInteraction) return;

            player.reputation = Math.max(0, player.reputation - 2); // Petite pénalité de réputation
            addLogMessage(`Vous avez refusé l'offre de ${currentOffer.toFixed(0)} € pour "${currentArtForSale.name}". ${currentCustomerInteraction.name} est parti.`);
            showMessage(`Offre refusée. ${currentCustomerInteraction.name} est parti.`, 'info');

            // Le client qui a refusé l'offre quitte le studio
            currentCustomerInteraction.state = 'leaving';

            resetCustomerInteraction();
            updateStatsDisplay();
        }

        /**
         * Réinitialise l'état de l'interaction client.
         */
        function resetCustomerInteraction() {
            customerInteraction.classList.add('hidden');
            currentCustomerInteraction = null;
            currentArtForSale = null;
            currentOffer = 0;
        }

        /**
         * Achète un article de la boutique.
         * @param {string} itemId - L'ID de l'article à acheter.
         */
        function buyShopItem(itemId) {
            const item = shopItems.find(i => i.id === itemId);
            if (!item) {
                showMessage("Article non trouvé.", 'error');
                return;
            }
            if (item.bought) {
                showMessage("Vous avez déjà acheté cet article.", 'info');
                return;
            }
            if (player.money < item.cost) {
                showMessage("Pas assez d'argent pour acheter cet article.", 'error');
                return;
            }

            player.money -= item.cost;
            player.upgrades.push(item);
            item.bought = true; // Marque l'article comme acheté

            // Applique les effets de l'amélioration
            if (item.effect) {
                if (item.effect.fame) player.fame += item.effect.fame;
                if (item.effect.reputation) player.reputation += item.effect.reputation;
                // D'autres effets peuvent être ajoutés ici
            }

            addLogMessage(`Vous avez acheté "${item.name}" pour ${item.cost} €. Votre studio est amélioré !`);
            showMessage(`"${item.name}" acheté !`, 'success');
            updateStatsDisplay();
            updateShopDisplay(); // Met à jour la boutique pour désactiver le bouton
            drawStudio(); // Redessine le studio avec le nouvel objet
        }

        // --- Tutoriel ---
        const tutorialSteps = [
            { message: `Bonjour, ${player.name} ! Bienvenue dans votre nouveau salon d'artiste. Je suis votre guide.`, npcX: 100, npcY: studioCanvas.height / 2 - 50 },
            { message: "C'est ici que vous allez créer vos chefs-d'œuvre. Utilisez le pinceau et la palette de couleurs en haut pour dessiner sur le chevalet.", npcX: 700, npcY: studioCanvas.height / 2 - 50 },
            { message: "Une fois satisfait, cliquez sur 'Terminer l'œuvre'. Elle apparaîtra dans votre galerie en bas.", npcX: 700, npcY: studioCanvas.height / 2 - 50 },
            { message: "Des clients viendront visiter votre salon. Vous pourrez leur proposer vos œuvres à la vente.", npcX: 100, npcY: studioCanvas.height / 2 - 50 },
            { message: "Gardez un œil sur votre Argent, votre Réputation et votre Renommée en haut de l'écran. La renommée attire de meilleurs clients !", npcX: 300, npcY: 50 },
            { message: "N'oubliez pas de visiter la Boutique d'Améliorations. Vous pouvez y acheter des objets pour embellir votre studio et améliorer vos compétences.", npcX: 300, npcY: 50 },
            { message: "Et attention au loyer ! Il est dû tous les 30 jours. Vendez vos œuvres pour ne pas vous retrouver sans le sou.", npcX: 300, npcY: 50 },
            { message: "Maintenant, à vous de jouer, ${player.name} ! Bonne chance dans votre carrière artistique !", npcX: 100, npcY: studioCanvas.height / 2 - 50, final: true }
        ];

        function startTutorial() {
            tutorialActive = true;
            tutorialStep = 0;
            tutorialNPC = {
                name: "Guide",
                x: -50, // Commence hors écran
                y: studioCanvas.height / 2,
                speed: 2,
                targetX: 100, // Position initiale du guide
                state: 'entering',
                colors: { body: '#805ad5', head: '#f6e0b5' }, // Couleurs du PNJ guide
                draw: function(ctx, x, y, size) { // Fonction de dessin pour le PNJ
                    const s = size / 8;
                    ctx.fillStyle = this.colors.body;
                    ctx.fillRect(x + s*2, y + s*4, s*4, s*4);
                    ctx.fillStyle = this.colors.head;
                    ctx.fillRect(x + s*3, y + s*1, s*2, s*3);
                }
            };
            tutorialDialog.classList.remove('hidden');
            advanceTutorial();
        }

        function advanceTutorial() {
            if (tutorialStep < tutorialSteps.length) {
                const step = tutorialSteps[tutorialStep];
                tutorialMessage.textContent = step.message.replace("${player.name}", player.name);
                tutorialNPC.targetX = step.npcX;
                tutorialNPC.y = step.npcY; // Ajuste la hauteur du PNJ si nécessaire pour le dialogue

                if (step.final) {
                    nextTutorialBtn.textContent = "Commencer le jeu !";
                }
                tutorialStep++;
            } else {
                tutorialActive = false;
                tutorialDialog.classList.add('hidden');
                tutorialNPC.state = 'leaving'; // Le PNJ quitte l'écran
                setInterval(spawnCustomer, 10000); // Commence à faire apparaître les clients
            }
        }

        // --- Rendu du Studio sur Canvas ---

        /**
         * Dessine un personnage pixelisé (joueur ou PNJ).
         * @param {CanvasRenderingContext2D} ctx - Contexte du canvas.
         * @param {object} char - L'objet personnage avec ses couleurs et sa fonction de dessin.
         * @param {number} x - Position X.
         * @param {number} y - Position Y.
         * @param {number} size - Taille du personnage.
         */
        function drawPixelCharacter(ctx, char, x, y, size) {
            char.draw(ctx, x, y, size);
        }

        /**
         * Dessine les éléments du studio sur le canvas.
         */
        function drawStudio() {
            ctx.clearRect(0, 0, studioCanvas.width, studioCanvas.height); // Efface le canvas

            // Fond du studio (mur et sol)
            ctx.fillStyle = '#a0aec0'; // Couleur du mur
            ctx.fillRect(0, 0, studioCanvas.width, studioCanvas.height - 80);
            ctx.fillStyle = '#718096'; // Couleur du sol
            ctx.fillRect(0, studioCanvas.height - 80, studioCanvas.width, 80);

            // Fenêtre (pixel art simplifié)
            ctx.fillStyle = '#bfdbfe'; // Bleu clair pour la fenêtre
            ctx.fillRect(studioCanvas.width - 150, 50, 100, 100);
            ctx.fillStyle = '#4a5568';
            ctx.fillRect(studioCanvas.width - 150, 95, 100, 10); // Barre horizontale
            ctx.fillRect(studioCanvas.width - 105, 50, 10, 100); // Barre verticale

            // Dessine les améliorations du studio
            player.upgrades.forEach(upgrade => {
                if (upgrade.type === 'decor') {
                    // Tableau décoratif pixelisé
                    ctx.fillStyle = '#a78bfa';
                    ctx.fillRect(upgrade.studioX, upgrade.studioY, upgrade.width, upgrade.height);
                    ctx.fillStyle = '#6d28d9';
                    ctx.fillRect(upgrade.studioX + 10, upgrade.studioY + 10, upgrade.width - 20, upgrade.height - 20);
                }
                if (upgrade.type === 'light') {
                    // Lampe au plafond pixelisée
                    ctx.fillStyle = '#fcd34d';
                    ctx.fillRect(upgrade.studioX - upgrade.width / 2, upgrade.studioY, upgrade.width, upgrade.height / 2);
                    ctx.fillStyle = '#d97706';
                    ctx.fillRect(upgrade.studioX - upgrade.width / 4, upgrade.studioY + upgrade.height / 2, upgrade.width / 2, upgrade.height / 2);
                }
                if (upgrade.type === 'sofa') {
                    // Canapé pixelisé
                    ctx.fillStyle = '#9f7aea';
                    ctx.fillRect(upgrade.studioX, upgrade.studioY, upgrade.width, upgrade.height);
                    ctx.fillStyle = '#8b5cf6';
                    ctx.fillRect(upgrade.studioX, upgrade.studioY - 20, upgrade.width, 20); // Dossier
                }
            });

            // Dessine le chevalet (toujours présent, même sans l'amélioration)
            ctx.fillStyle = '#8b4513'; // Marron
            ctx.fillRect(artDrawingArea.x + artDrawingArea.width / 2 - 10, artDrawingArea.y + artDrawingArea.height, 20, 80); // Pied
            ctx.beginPath();
            ctx.moveTo(artDrawingArea.x + artDrawingArea.width / 2 - 10, artDrawingArea.y + artDrawingArea.height);
            ctx.lineTo(artDrawingArea.x + artDrawingArea.width / 2 - 50, studioCanvas.height - 80);
            ctx.moveTo(artDrawingArea.x + artDrawingArea.width / 2 + 10, artDrawingArea.y + artDrawingArea.height);
            ctx.lineTo(artDrawingArea.x + artDrawingArea.width / 2 + 50, studioCanvas.height - 80);
            ctx.stroke();

            // Dessine la zone de dessin (le cadre du tableau)
            ctx.fillStyle = '#333';
            ctx.fillRect(artDrawingArea.x - 5, artDrawingArea.y - 5, artDrawingArea.width + 10, artDrawingArea.height + 10);
            ctx.fillStyle = '#ffffff'; // Fond blanc du tableau
            ctx.fillRect(artDrawingArea.x, artDrawingArea.y, artDrawingArea.width, artDrawingArea.height);

            // Redessine le contenu du dessin en cours si il existe
            if (currentDrawingData) {
                const img = new Image();
                img.src = currentDrawingData;
                img.onload = () => {
                    ctx.drawImage(img, artDrawingArea.x, artDrawingArea.y, artDrawingArea.width, artDrawingArea.height);
                };
            }

            // Dessine le joueur
            if (player.character) {
                drawPixelCharacter(ctx, player.character, artDrawingArea.x + artDrawingArea.width / 2 - 32, studioCanvas.height - 150, 64);
            }

            // Dessine le PNJ du tutoriel
            if (tutorialNPC) {
                drawPixelCharacter(ctx, tutorialNPC, tutorialNPC.x, tutorialNPC.y - 70, 64);
            }

            // Dessine les clients
            customers.forEach(customer => {
                drawPixelCharacter(ctx, { colors: customer.colors, draw: pixelCharacters[0].draw }, customer.x, customer.y - 70, 64); // Utilise la fonction de dessin du premier personnage pour les clients
            });
        }

        /**
         * Boucle d'animation principale du jeu.
         */
        function animate() {
            drawStudio(); // Dessine le studio et ses éléments
            requestAnimationFrame(animate); // Demande au navigateur de rappeler animate pour le prochain rafraîchissement
        }
    </script>
</body>
</html>
